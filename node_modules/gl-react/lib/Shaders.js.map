{"version":3,"sources":["../src/Shaders.js"],"names":["ShaderID","shaderDefinitions","shaderNames","shaderResults","genShaderId","i","toString","staticVert","isShaderIdentifier","shaderIdentifier","type","id","ensureShaderDefinition","definition","ctx","frag","shaderDefinitionToShaderInfo","vert","shaderInfoEquals","s1","s2","Shaders","global","__glReactShaders","create","shadersDef","sheet","Object","keys","forEach","k","shaderId","freeze","result","getName","String","getShortName","get"],"mappings":"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","sourcesContent":["//@flow\nimport invariant from \"invariant\";\nimport GLSL from \"./GLSL\";\nimport type { GLSLCode } from \"./GLSL\";\n\nconst ShaderID = \"ShaderID\";\n\n/**\n * An object that contains a `frag` GLSLCode.\n * @example\n *  {\n *    frag: GLSL`...`\n *  }\n */\ntype ShaderDefinition = {|\n  frag: GLSLCode,\n  vert?: GLSLCode,\n|};\n\nexport type { ShaderDefinition };\n\n/**\n *\n */\ntype ShaderIdentifier = {\n  type: typeof ShaderID,\n  id: string,\n};\n\nexport type { ShaderIdentifier };\n\ntype ShaderIdentifierMap<T> = {\n  [key: string]: T,\n};\n\n/**\n * An object map from a key string to a **ShaderDefinition**.\n * @example\n *  {\n *    helloGL: {\n *      frag: GLSL`...`\n *    }\n *  }\n */\ntype ShadersDefinition = {\n  [key: string]: ShaderDefinition,\n};\n\n/**\n * An object map from a key string to a **ShaderIdentifier** that you can pass to `<Node shader>`\n */\ntype ShadersSheet<S: ShadersDefinition> = {\n  [key: $Keys<S>]: ShaderIdentifier,\n};\n\ntype ShaderInfo = {\n  frag: GLSLCode,\n  vert: GLSLCode,\n};\n\nexport type { ShaderInfo };\n\nconst shaderDefinitions: ShaderIdentifierMap<ShaderDefinition> = {};\nconst shaderNames: ShaderIdentifierMap<string> = {};\nconst shaderResults: ShaderIdentifierMap<ShaderInfo> = {};\n\nconst genShaderId = ((i) => () => (++i).toString())(0);\n\nconst staticVert = GLSL`\nattribute vec2 _p;\nvarying vec2 uv;\nvoid main() {\ngl_Position = vec4(_p,0.0,1.0);\nuv = vec2(0.5, 0.5) * (_p+vec2(1.0, 1.0));\n}`;\n\nexport function isShaderIdentifier(shaderIdentifier: mixed): boolean {\n  return (\n    typeof shaderIdentifier === \"object\" &&\n    !!shaderIdentifier &&\n    shaderIdentifier.type === ShaderID &&\n    typeof shaderIdentifier.id === \"string\"\n  );\n}\n\nexport function ensureShaderDefinition(\n  definition: any,\n  ctx?: string = \"\"\n): ShaderDefinition {\n  invariant(\n    definition && typeof definition.frag === \"string\",\n    \"A `frag` GLSL code (string) is required\" + ctx\n  );\n  return definition;\n}\n\nexport function shaderDefinitionToShaderInfo(\n  definition: ShaderDefinition\n): ShaderInfo {\n  return {\n    frag: definition.frag,\n    vert: definition.vert || staticVert, // FIXME this is somewhat experimental for now, vert implement needs to expect a _p attribute\n  };\n}\n\nexport function shaderInfoEquals(s1: ShaderInfo, s2: ShaderInfo): boolean {\n  return s1.frag === s2.frag && s1.vert === s2.vert;\n}\n\n/**\n * Define shaders statically.\n * @namespace\n */\nconst Shaders = (global.__glReactShaders = global.__glReactShaders || {\n  /**\n   * @memberof Shaders\n   * @param {ShadersDefinition} shadersDef - an object that statically define all shaders.\n   * @returns {ShadersSheet}, an object map that returns a ShaderIdentifier for each shader key defined in the shaders definition.\n   * @example\n   *  const shaders = Shaders.create({\n   *    helloGL: {\n   *      frag: GLSL`...`\n   *    }\n   *  });\n   *  ...\n   *  <Node shader={shaders.helloGL} />\n   */\n  create<S: ShadersDefinition>(shadersDef: S): ShadersSheet<S> {\n    const sheet = {};\n    Object.keys(shadersDef).forEach((k) => {\n      const definition = ensureShaderDefinition(\n        shadersDef[k],\n        \" in Shaders.create({ \" + k + \": ... })\"\n      );\n      const id = genShaderId();\n      const shaderId = Object.freeze({ type: ShaderID, id });\n      shaderDefinitions[id] = definition;\n      shaderNames[id] = k;\n      sheet[k] = shaderId;\n      const result = shaderDefinitionToShaderInfo(definition);\n      shaderResults[id] = result;\n    });\n    return sheet;\n  },\n  getName(shaderIdentifier: ShaderIdentifier): string {\n    return (\n      (shaderNames[shaderIdentifier.id] || \"???\") +\n      `#${String(shaderIdentifier.id)}`\n    );\n  },\n  getShortName(shaderIdentifier: ShaderIdentifier): string {\n    return shaderNames[shaderIdentifier.id] || \"???\";\n  },\n  get(shaderIdentifier: ShaderIdentifier): ShaderInfo {\n    invariant(\n      shaderIdentifier.id in shaderDefinitions,\n      \"Shader %s does not exist. Make sure you don't have gl-react dup issue: `npm ls gl-react`\",\n      shaderIdentifier.id\n    );\n    return shaderResults[shaderIdentifier.id];\n  },\n});\nexport default Shaders;\n"],"file":"Shaders.js"}